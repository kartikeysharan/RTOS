/*
 * MPU.c
 *
 *      Author: kartikey
 */
#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include "uart0.h"
#include "RTOSlibrary.h"
#include "wait.h"
#include "clock.h"
#include "tm4c123gh6pm.h"
#include "MPU.h"
#include "hardware.h"
#include "gpio.h"
#include "uart_UI.h"

/*extern void setPsp(uint32_t * add);
extern void setAspBit();
extern void switchToUnprivilegeMode();
extern uint32_t* MSPValue();
extern uint32_t* PSPValue();*/
uint32_t* ProgramBreak = (uint32_t*)0x20008000;

void enableMPU()
{
    NVIC_MPU_CTRL_R |= NVIC_MPU_CTRL_ENABLE; //Enables the MPU by setting the MPU Control register (pg 187)

    putsUart0("\n\nMPU has been enabled. It can only go downhill from here");
    LEDFlashSequence();
}

void setPsp(uint32_t * add)
{
    __asm(" MSR PSP, R0");  //Setting PSP to the value in R0
    __asm(" ISB");          //Exectues all instructions in the pipeline

    putsUart0("\n\nPSP has been set to ");
    printUint32t2Hex((uint32_t)add);

    setPinValue(GREEN_LED, 1);
    waitMicrosecond(100000);
    setPinValue(GREEN_LED, 0);
}

void setAspBit()
{
    __asm(" MRS R0, CONTROL"); //Moving control register to R0 for modification
    __asm(" ORRS R0, #2");     //Setting the ASP bit in the control register
    __asm(" MSR CONTROL, R0"); //Moving R0 back to control register
    __asm(" ISB");             //Exectues all instructions in the pipeline before setting the ASP bit
}

void switchToUnprivilegeMode()
{
    __asm(" MRS R0, CONTROL"); //Moving control register to R0 for modification
    __asm(" ORRS R0, #1");     //Setting the TMPL bit in control register.
    __asm(" MSR CONTROL, R0"); //Moving R0 back to control register
    __asm(" ISB");

    putsUart0("\n\nUNPRIVILEGED MODE TURNED ON");
    setPinValue(RED_LED, 1);
    waitMicrosecond(100000);
    setPinValue(RED_LED, 0);
}

uint32_t* MSPValue()
{
    __asm(" MRS R0, MSP");  //Getting value of MSP in R0
}

uint32_t* PSPValue()
{
    __asm(" MRS R0, PSP"); //Getting value of PSP in R0
}

void BusFaultISR()
{
    putsUart0("\n\nBus fault in process: ");
    printUint32t2Hex(pid);
    //
    // Enter an infinite loop.
    //
    while(1)
    {
        setPinValue(YELLOW_LED, 1);
        waitMicrosecond(100000);
        setPinValue(YELLOW_LED, 0);
        waitMicrosecond(100000);
    }
}

void UsageFaultISR()
{
    putsUart0("\n\nUsage fault in process: ");
    printUint32t2Hex(pid);
    //
    // Enter an infinite loop.
    //
    while(1)
    {
        setPinValue(ORANGE_LED, 1);
        waitMicrosecond(100000);
        setPinValue(ORANGE_LED, 0);
        waitMicrosecond(100000);
    }
}

void FaultISR(void)
{

    putsUart0("\n\nHard fault in process: ");
    printUint32t2Hex(pid);

    uint32_t* mspValue = MSPValue();            //Getting the msp value
    uint32_t* pspValue = PSPValue();            //Getting the psp value

    putsUart0("\n\nMSP: ");
    printUint32t2Hex((uint32_t)mspValue);

    putsUart0("\nPSP: ");
    printUint32t2Hex((uint32_t)pspValue);

    putsUart0("\n\nHard Fault Flags(HEX): ");

    /*Hard Fault status register can only be accessed from privileged mode
    Bits are cleared by writing a 1 to them.
    Bit Field 30: A forced hard fault has been generated by escalation of a fault
                  with configurable priority that cannot be handled.
    Bit Field 01: Vector Table Read Fault. A bus fault occurred on a vector table read. */

    printUint32t2Hex(NVIC_HFAULT_STAT_R);      //Hard fault flags from Hard Fault status register

    //
    // Enter an infinite loop.
    //
    while(1)
    {
        setPinValue(RED_LED, 1);
        setPinValue(GREEN_LED, 1);
        setPinValue(YELLOW_LED, 1);
        setPinValue(ORANGE_LED, 1);
        waitMicrosecond(100000);
        setPinValue(RED_LED, 0);
        setPinValue(GREEN_LED, 0);
        setPinValue(YELLOW_LED, 0);
        setPinValue(ORANGE_LED, 0);
        waitMicrosecond(100000);
    }
}

void MPUFaultISR()
{
    putsUart0("\n\nMPU fault in process: ");
    printUint32t2Hex(pid);

    uint32_t* mspValue = MSPValue();            //Getting the msp value
    uint32_t* pspValue = PSPValue();            //Getting the psp value

    putsUart0("\n\nMSP: ");
    printUint32t2Hex((uint32_t)mspValue);

    putsUart0("\nPSP: ");
    printUint32t2Hex((uint32_t)pspValue);

    putsUart0("\n\nMPU fault Flags(HEX): ");
    printUint32t2Hex(NVIC_FAULT_STAT_R);          //MPU fault flags can be read from Fault status register

    if(NVIC_FAULT_STAT_R & NVIC_FAULT_STAT_MMARV) //Check if Memory Management Fault Address Register Valid
    {
        uint32_t impending = *(pspValue + 6);
        impending = *(uint32_t*)impending;        //Impending instruction that caused the MPU fault
        putsUart0("\n\nImpending Instruction: ");
        printUint32t2Hex(impending);

        putsUart0("\n\nFault at data address: ");
        printUint32t2Hex(NVIC_MM_ADDR_R);         //Data address where the faut was caused
    }

    else
    {
        putsUart0("\n\nInvalid data address for fault ");
    }

    putsUart0("\n\n******** Process Stack Dump ********\n");

    putsUart0("\nxPSR: ");
    printUint32t2Hex(*(pspValue + 7));

    putsUart0("\n\nPC: ");
    printUint32t2Hex(*(pspValue + 6));

    putsUart0("\n\nLR: ");
    printUint32t2Hex(*(pspValue + 5));

    putsUart0("\n\nRO: ");
    printUint32t2Hex(*(pspValue));

    putsUart0("\n\nR1: ");
    printUint32t2Hex(*(pspValue + 1));

    putsUart0("\n\nR2: ");
    printUint32t2Hex(*(pspValue + 2));

    putsUart0("\n\nR3: ");
    printUint32t2Hex(*(pspValue + 3));

    putsUart0("\n\nR12: ");
    printUint32t2Hex(*(pspValue + 4));

    NVIC_SYS_HND_CTRL_R &= ~NVIC_SYS_HND_CTRL_MEMP; //clear MPU fault pending bit

    setPinValue(GREEN_LED, 1);
    waitMicrosecond(100000);
    setPinValue(GREEN_LED, 0);

    NVIC_INT_CTRL_R |= NVIC_INT_CTRL_PEND_SV;       //trigger pendsv ISR call

}
void PendsvISR()
{
    putsUart0("\n\nPendsv in process: ");
    printUint32t2Hex(pid);

    if(NVIC_FAULT_STAT_R & (NVIC_FAULT_STAT_IERR | NVIC_FAULT_STAT_DERR)) //Check for Instruction Access Violation or Data Access Violation
    {
        NVIC_FAULT_STAT_R |= NVIC_FAULT_STAT_IERR; //clear IERR bit
        NVIC_FAULT_STAT_R |= NVIC_FAULT_STAT_DERR; //clear DERR bit
        putsUart0("\n\nCalled from MPU");
    }
    //
    // Enter an infinite loop.
    //
    while(1)
    {
        setPinValue(RED_LED, 1);
        waitMicrosecond(100000);
        setPinValue(RED_LED, 0);
        waitMicrosecond(100000);
    }

}
void enableInterruptHandler()
{
    NVIC_SYS_HND_CTRL_R |= NVIC_SYS_HND_CTRL_USAGE | NVIC_SYS_HND_CTRL_MEM | NVIC_SYS_HND_CTRL_BUS; //Usage, MPU, and Bus fault handlers enabled
}

//Size mask logic for all regions
//size is log2((size in KiB) * 1024)-1 shift left by 1

void overallAccess()
{
    NVIC_MPU_BASE_R = OVERALL_BASE_ADDR | NVIC_MPU_BASE_VALID | REG_0;
    NVIC_MPU_ATTR_R = NVIC_MPU_ATTR_AP_FULLACC | NVIC_MPU_ATTR_SHAREABLE | NVIC_MPU_ATTR_CACHEABLE | NVIC_MPU_ATTR_BUFFRABLE
                      | NVIC_MPU_ATTR_XN  | NVIC_MPU_ATTR_SIZE_M | NVIC_MPU_ATTR_ENABLE ;

    putsUart0("\n\nBackground region rule has been enabled\n\nRegion Properties: \nPrivileged Permissions \t-- RW\nUnprivileged Permissions \t-- RW");
    putsUart0("\nExecution Privileges \t\t-- Disabled \nShareable \t\t\t-- Y\nCacheable \t\t\t-- Y\nBuffarable \t\t\t-- Y");
    putsUart0("\nSize \t\t\t\t\t-- 4GiB");
    setPinValue(GREEN_LED, 1);
    waitMicrosecond(100000);
    setPinValue(GREEN_LED, 0);
}

void overallAccessNoPrivilege()
{
    NVIC_MPU_BASE_R = OVERALL_BASE_ADDR | NVIC_MPU_BASE_VALID | REG_0;
    NVIC_MPU_ATTR_R = NVIC_MPU_ATTR_AP_NOACC | NVIC_MPU_ATTR_SHAREABLE | NVIC_MPU_ATTR_CACHEABLE | NVIC_MPU_ATTR_BUFFRABLE
                      | NVIC_MPU_ATTR_XN  | NVIC_MPU_ATTR_SIZE_M | NVIC_MPU_ATTR_ENABLE ;

    putsUart0("\nBackground region rule has been enabled with no RW Privileges\n");
    putsUart0("\n\nBackground region rule has been enabled\nRegion Properties: \nPrivileged Permissions \t-- No Access\nUnprivileged Permissions \t-- No Access");
    putsUart0("\nExecution Privileges \t\t-- Disabled \nShareable \t\t\t-- Y\nCacheable \t\t\t-- Y\nBuffarable \t\t\t-- Y");
    putsUart0("\nSize \t\t\t\t\t-- 4GiB");
    setPinValue(RED_LED, 1);
    waitMicrosecond(100000);
    setPinValue(RED_LED, 0);
}

void allowFlashAccess(void)
{
    NVIC_MPU_BASE_R = FLASH_BASE_ADDR | NVIC_MPU_BASE_VALID | REG_1;
    NVIC_MPU_ATTR_R = NVIC_MPU_ATTR_AP_FULLACC | NVIC_MPU_ATTR_CACHEABLE | 34 | NVIC_MPU_ATTR_ENABLE;

    putsUart0("\n\nFlash region rule has been enabled\nRegion Properties: \nPrivileged Permissions \t-- RW\nUnprivileged Permissions \t-- RW");
    putsUart0("\nExecution Privileges \t\t-- Enabled \nShareable \t\t\t-- N\nCacheable \t\t\t-- Y\nBuffarable \t\t\t-- N");
    putsUart0("\nSize \t\t\t\t\t-- 256KiB");
    setPinValue(GREEN_LED, 1);
    waitMicrosecond(100000);
    setPinValue(GREEN_LED, 0);
}

void allowFlashAccessNoPrivilege(void)
{
    NVIC_MPU_BASE_R = FLASH_BASE_ADDR | NVIC_MPU_BASE_VALID | REG_1;
    NVIC_MPU_ATTR_R = NVIC_MPU_ATTR_AP_NOACC | NVIC_MPU_ATTR_CACHEABLE | 34 | NVIC_MPU_ATTR_ENABLE;

    putsUart0("\n\nFlash region rule has been enabled with no RW Privileges\nRegion Properties: \nPrivileged Permissions \t-- No Access\nUnprivileged Permissions \t-- No Access");
    putsUart0("\nExecution Privileges \t\t-- Enabled \nShareable \t\t\t-- N\nCacheable \t\t\t-- Y\nBuffarable \t\t\t-- N");
    putsUart0("\nSize \t\t\t\t\t-- 256KiB");
    setPinValue(RED_LED, 1);
    waitMicrosecond(100000);
    setPinValue(RED_LED, 0);
}

void allowPeripheralAccess(void)
{
    NVIC_MPU_BASE_R = PERIPHERAL_BASE_ADDR | NVIC_MPU_BASE_VALID | REG_2;
    NVIC_MPU_ATTR_R = NVIC_MPU_ATTR_AP_FULLACC | NVIC_MPU_ATTR_SHAREABLE | NVIC_MPU_ATTR_BUFFRABLE | 50 | NVIC_MPU_ATTR_XN | NVIC_MPU_ATTR_ENABLE;

    putsUart0("\n\nPeripheral region rule has been enabled\nRegion Properties: \nPrivileged Permissions \t-- RW\nUnprivileged Permissions \t-- RW");
    putsUart0("\nExecution Privileges \t\t-- Disabled \nShareable \t\t\t-- Y\nCacheable \t\t\t-- N\nBuffarable \t\t\t-- Y");
    putsUart0("\nSize \t\t\t\t\t-- 65535KiB");
    setPinValue(GREEN_LED, 1);
    waitMicrosecond(100000);
    setPinValue(GREEN_LED, 0);
}

void allowPeripheralAccessNoPrivilege(void)
{
    NVIC_MPU_BASE_R = PERIPHERAL_BASE_ADDR | NVIC_MPU_BASE_VALID | REG_2;
    NVIC_MPU_ATTR_R = NVIC_MPU_ATTR_AP_NOACC | NVIC_MPU_ATTR_SHAREABLE | NVIC_MPU_ATTR_BUFFRABLE | 50 | NVIC_MPU_ATTR_XN | NVIC_MPU_ATTR_ENABLE;

    putsUart0("\n\nPeripheral region rule has been enabled with no RW Privileges\nRegion Properties: \nPrivileged Permissions \t-- No Access\nUnprivileged Permissions \t-- No Access");
    putsUart0("\nExecution Privileges \t\t-- Disabled \nShareable \t\t\t-- Y\nCacheable \t\t\t-- N\nBuffarable \t\t\t-- Y");
    putsUart0("\nSize \t\t\t\t\t-- 65535KiB");
    setPinValue(RED_LED, 1);
    waitMicrosecond(100000);
    setPinValue(RED_LED, 0);
}

void setupSramAccess(void)
{
    NVIC_MPU_BASE_R = SRAM_0 | NVIC_MPU_BASE_VALID | REG_3;
    NVIC_MPU_ATTR_R = NVIC_MPU_ATTR_AP_PRIVRW | NVIC_MPU_ATTR_SHAREABLE | NVIC_MPU_ATTR_CACHEABLE | 24 | NVIC_MPU_ATTR_XN | NVIC_MPU_ATTR_ENABLE;
    putsUart0("\n\nSRAM region 0 rule has been enabled\n");
    putsUart0("\nSize \t\t\t\t\t-- 8KiB");

    NVIC_MPU_BASE_R = SRAM_1 | NVIC_MPU_BASE_VALID | REG_4;
    NVIC_MPU_ATTR_R = NVIC_MPU_ATTR_AP_PRIVRW | NVIC_MPU_ATTR_SHAREABLE | NVIC_MPU_ATTR_CACHEABLE | 24 | NVIC_MPU_ATTR_XN | NVIC_MPU_ATTR_ENABLE;
    putsUart0("\n\nSRAM region 1 rule has been enabled\n");
    putsUart0("\nSize \t\t\t\t\t-- 8KiB");

    NVIC_MPU_BASE_R = SRAM_2 | NVIC_MPU_BASE_VALID | REG_5;
    NVIC_MPU_ATTR_R = NVIC_MPU_ATTR_AP_PRIVRW | NVIC_MPU_ATTR_SHAREABLE | NVIC_MPU_ATTR_CACHEABLE | 24 | NVIC_MPU_ATTR_XN | NVIC_MPU_ATTR_ENABLE;
    putsUart0("\n\nSRAM region 2 rule has been enabled\n");
    putsUart0("\nSize \t\t\t\t\t-- 8KiB");

    NVIC_MPU_BASE_R = SRAM_3 | NVIC_MPU_BASE_VALID | REG_6;
    NVIC_MPU_ATTR_R = NVIC_MPU_ATTR_AP_PRIVRW | NVIC_MPU_ATTR_SHAREABLE | NVIC_MPU_ATTR_CACHEABLE | 22 | NVIC_MPU_ATTR_XN | NVIC_MPU_ATTR_ENABLE;
    putsUart0("\n\nSRAM region 3 rule has been enabled\n");
    putsUart0("\nSize \t\t\t\t\t-- 4KiB");

    NVIC_MPU_BASE_R = SRAM_4 | NVIC_MPU_BASE_VALID | REG_7;
    NVIC_MPU_ATTR_R = NVIC_MPU_ATTR_AP_PRIVRW | NVIC_MPU_ATTR_SHAREABLE | NVIC_MPU_ATTR_CACHEABLE | 22 | NVIC_MPU_ATTR_XN | NVIC_MPU_ATTR_ENABLE;
    putsUart0("\n\nSRAM region 4 rule has been enabled\n");
    putsUart0("\nSize \t\t\t\t\t-- 4KiB");

    putsUart0("\n\nAll SRAM region rules have been enabled\nRegion Properties: \nPrivileged Permissions \t-- RW\nUnprivileged Permissions \t-- No Access");
    putsUart0("\nExecution Privileges \t\t-- Disabled \nShareable \t\t\t-- Y\nCacheable \t\t\t-- Y\nBuffarable \t\t\t-- N");
    putsUart0("\nSize \t\t\t\t\t-- 32KiB");

    setPinValue(GREEN_LED, 1);
    waitMicrosecond(100000);
    setPinValue(GREEN_LED, 0);
}

void setSramAccessWindow(uint32_t baseAdd, uint32_t size_in_bytes)
{
    if((baseAdd>SRAM_END) && (baseAdd<SRAM_START))
    {
        return;
    }

    //Disabling all SRAM regions on function call

    NVIC_MPU_NUMBER_R = SRAM_0 + REG_3;
    NVIC_MPU_ATTR_R &= ~(0x0000FF00);

    NVIC_MPU_NUMBER_R = SRAM_1 + REG_3;
    NVIC_MPU_ATTR_R &= ~(0x0000FF00);

    NVIC_MPU_NUMBER_R = SRAM_2 + REG_3;
    NVIC_MPU_ATTR_R &= ~(0x0000FF00);

    NVIC_MPU_NUMBER_R = SRAM_3 + REG_3;
    NVIC_MPU_ATTR_R &= ~(0x0000FF00);

    NVIC_MPU_NUMBER_R = SRAM_4 + REG_3;
    NVIC_MPU_ATTR_R &= ~(0x0000FF00);

    uint32_t sram_region = 0;
    uint32_t new_region = 0;
    uint32_t sram_SubRegion = 0;
    int k = 0;

    //Finding out which region and subregion the baseaddress belongs to

    if(baseAdd >= 0x20006000 && baseAdd < 0x20007000)
    {
        sram_region = 3;
        sram_SubRegion = (baseAdd - SRAM_3)/512;        //Since each subregion in this region is 512 bytes
    }
    else if (baseAdd >= 0x20007000 && baseAdd < 0x20008000)
    {
        sram_region = 4;
        sram_SubRegion = ((baseAdd - SRAM_4)/512);      //Since each subregion in this region is 512 bytes
    }
    else
    {
        sram_region = (baseAdd - SRAM_0) / 8192;
        sram_SubRegion = (baseAdd - (SRAM_0 + (sram_region * 8192)))/1024; //Since each subregion in this region is 1024 bytes
    }

    sram_region = sram_region+REG_3; //Adding the region offset to where SRAM lives

    //Setting the starting SRAM region based on base address

    NVIC_MPU_NUMBER_R = sram_region;
    NVIC_MPU_ATTR_R &= ~(0x0000FF00);

    //If user only wants one block of 512 bytes from region 6 and 7
    if(size_in_bytes <= 512)
    {
        if(baseAdd < 0x20006000)
        {
            putsUart0("\nCan't allot 512 bytes in requested region\n");
            return;
        }
        else
        {
            sram_region = sram_region+REG_3;

            NVIC_MPU_NUMBER_R = sram_region;
            NVIC_MPU_ATTR_R &= ~(0x0000FF00);

            NVIC_MPU_ATTR_R |= (1 << sram_SubRegion) << 8;
        }
    }

    //If user wants more than 512 bytes form any SRAM regions
    else
    {
        size_in_bytes = (((size_in_bytes-1)/1024)+1) * 1024; //Size in bytes rounded to nearest kib

        k = (size_in_bytes / 1024); //Number of iterations required

        int j = 0;
        int i = 0;
        int f = 0;
        int l = 0;
        for(i = 0; i < k; i++)
        {
            //if setting access window in region 6 and 7, set two SRD bits for each 1024 bytes
            if((sram_region == 6) || (sram_region == 7))
            {
                new_region = sram_SubRegion/2;
                j = (i + sram_SubRegion)%4;     //Set to 0 after four iterations to set SRD bits in the next region.
                l = (i + new_region)%4;         //Set to 0 after four iterations to get to the next region.

                if (l == 0 && i != 0)           //If access window covers the next SRAM region as well
                {
                    sram_region = sram_region + 1;
                    NVIC_MPU_NUMBER_R = sram_region;  //Setting the next SRAM region in Number register
                    f = 0;
                }
                NVIC_MPU_ATTR_R |= (1 << j+f) << 8;     //Setting SRD bit
                NVIC_MPU_ATTR_R |= (1 << (j+f+1)) << 8; //Setting consecutive SRD bit

                f++;
            }
            else
            {
                j = (i + sram_SubRegion) % 8;   //Set to 0 after eight iterations to set SRD bits in the next region.
                if (j == 0 && i != 0)           //If access window covers the next SRAM region as well
                {
                    sram_region = sram_region + 1;
                    NVIC_MPU_NUMBER_R = sram_region; //Setting the next SRAM region in Number register
                }
                if (sram_region == 6)   //Decrementing the counter going from 8 kib region to 4 kib region
                {
                    i--;
                }
                else
                {
                    NVIC_MPU_ATTR_R |= (1 << j) << 8; //Setting SRD bit
                }
            }

        }
    }

    putsUart0("\n\nBase Address to Access: ");
    printUint32t2Hex(baseAdd);

    putsUart0("\n\nSize to Allocate: ");
    printUint32t2Hex(size_in_bytes);

    putsUart0("\n\nEquivalent SRAM Region to access:\t ");
    printUint32t2Hex(sram_region);

    putsUart0("\n\nEquivalent SRAM Sub Region to access: ");
    printUint32t2Hex(sram_SubRegion);

    putsUart0("\n\nSRAM access window successfully set up");
    LEDFlashSequenceReverse();
}

void* malloc_From_Heap(int size_in_bytes)
{
    putsUart0("\n\nMemory allocation starts at: ");
    printUint32t2Hex((uint32_t)ProgramBreak);

    void* p = ProgramBreak; //Pointer to the top of SRAM to start memory allocation

    if(size_in_bytes<=512)  //Alocating 512 bytes of memory
    {
        p = p - 512; //Decrementing 512 bytes

        if(p<0x200013FF + 1) //To make sure not to run into space reserved by the OS
        {
            return 0;
        }

        putsUart0("\n\nAllocated memory pointer from malloc: ");
        printUint32t2Hex((uint32_t)p);

        putsUart0("\nMemory size requested: ");
        printUint32t2Hex((uint32_t)size_in_bytes);
        putsUart0("\nMemory size allocated: ");
        printUint32t2Hex(size_in_bytes);

        ProgramBreak = p; //Updating the Program break to new location
        return p;         //Returning the new memory address
    }
    else //Allocating more than 512 bytes
    {
        int size_in_bytes_updated = 0;
        size_in_bytes_updated = (((size_in_bytes-1)/1024)+1) * 1024; //Rounding the memory to nearest KiB
        p = p - size_in_bytes_updated;  //Decrementing the required memory

        if(p<0x200013FF + 1) //To make sure not to run into space reserved by the OS
        {
            return 0;
        }

        putsUart0("\n\nAllocated memory pointer from malloc: ");
        printUint32t2Hex((uint32_t)p);

        putsUart0("\nMemory size requested: ");
        printUint32t2Hex((uint32_t)size_in_bytes);
        putsUart0("\nMemory size allocated: ");
        printUint32t2Hex(size_in_bytes_updated);

        ProgramBreak = p; //Updating the Program break to new location
        return p;         //Returning the new memory address

    }

}
//************* Peripherals Testing *************\\

void SRAMAcessTest()
{
    putsUart0("\n\n******** SRAM Access Test ********");

    //uint32_t* p = (uint32_t*)0x20001000;
    uint32_t* p = (uint32_t*)0x20005000;

    setSramAccessWindow((uint32_t)p,6000);

    switchToUnprivilegeMode();

    putsUart0("\n\nAttempting to Write 100 to: ");
    printUint32t2Hex((uint32_t)p);

    *p = 100; //works

    putsUart0("\n\nValue at location: ");
    printUint32t2Hex((uint32_t)* p);

    //*(p-0x1500) = 100; //Bus Fault

    //*(p-1) = 100; //MPU Fault
}

void SRAMAccessRestricted()
{
    putsUart0("\n\n******** SRAM Resricted Access Test ********");

    uint32_t* p = malloc_From_Heap(1024);

    setSramAccessWindow((uint32_t)p,1024);

    switchToUnprivilegeMode();

    putsUart0("\n\nAttempting to Write 100 to: ");
    printUint32t2Hex((uint32_t)p);

    *p = 100; //works

    putsUart0("\n\nValue at location: ");
    printUint32t2Hex((uint32_t)* p);

    //*(p+256) = 100; //Hard Fault

    //*(p-1) = 100; //MPU Fault
}

void mallocTest()
{
    putsUart0("\n\n******** Malloc Test ********");

    uint32_t* p = malloc_From_Heap(500);
    uint32_t* q = malloc_From_Heap(1026);
    uint32_t* r = malloc_From_Heap(2050);
}

void usageFaultTest()
{
    int i = 0;
    int k = 0;
    int j = i/k;
}

void busFaultTest()
{
    int volatile * const p_reg = (int *) 0x8FFFFFFF;
    *p_reg = 0x1234;
}

void flashAccessTest()
{
    putsUart0("\n\n******** Flash Access Test ********");
    putsUart0("\n\nCount to 5");
    waitMicrosecond(5000000);
    putsUart0("\n\n If you are reading this after 5 seconds, Flash works ");
}

void peripheralAccessTest()
{
    putsUart0("\n\n******** Peripheral Access Test ********");
    MY_RED_LED = 1;
    putsUart0("\n\n If you see a RED LED on, Peripheral works ");
    waitMicrosecond(1000000);
    MY_RED_LED = 0;
}

void pendSvTest()
{
    NVIC_INT_CTRL_R |= NVIC_INT_CTRL_PEND_SV;
}
void memProtectionTest()
{
    NVIC_SYS_HND_CTRL_R |= NVIC_SYS_HND_CTRL_MEMP;
}

void hardFaultTest()
{
    NVIC_MPU_CTRL_R |= NVIC_MPU_CTRL_ENABLE;
}

void faultTestsDemo()
{
    bool flag = true;
    putsUart0("\n\n******** Fault Test Demo Function ********");
    putsUart0("\n\n0) Usage Fault test\n1) Bus Fault Test \n2) MPU Fault Test \n3) PendSV Test \n4) Hard Fault Test \n5) Exit");
    while(flag)
    {
        //Usage Fault Test
        if(!getPinValue(PUSH_BUTTON_0))
        {
            putsUart0("\n\n******** Usage Fault Test ********");
            usageFaultTest();
        }
        //Bus Fault Test
        if(!getPinValue(PUSH_BUTTON_1))
        {
            putsUart0("\n\n******** Bus Fault Test ********");
            busFaultTest();
        }
        //Memory Protection Test
        if(!getPinValue(PUSH_BUTTON_2))
        {
            putsUart0("\n\n******** MPU Fault Test ********");
            NVIC_SYS_HND_CTRL_R |= NVIC_SYS_HND_CTRL_MEMP;
        }
        //PendSV Test
        if(!getPinValue(PUSH_BUTTON_3))
        {
            putsUart0("\n\n******** PendSV Test ********");
            NVIC_INT_CTRL_R |= NVIC_INT_CTRL_PEND_SV;
        }
        //Hard Fault Test
        if(!getPinValue(PUSH_BUTTON_4))
        {
            putsUart0("\n\n******** Hard Fault Test ********");
            hardFaultTest();
        }
        if(!getPinValue(PUSH_BUTTON_5))
        {
            flag = false;
        }
    }

}
